\documentclass[11pt]{article}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}

\oddsidemargin-1cm
\topmargin-2cm
\textwidth18.5cm
\textheight23.5cm  
 
\newcommand{\assignment}{P3 Proposal}
\newcommand{\duedate}{April 15, 2014}
\newcommand{\header}{\noindent \textbf{15-440, Spring 2014 \\ \assignment \\ 
                     Connor Brem (cbrem), Billy Wood (wtwood) \\ \duedate} 
                     \vspace{0.10in} \hrule}

\begin{document}
\header

\section*{Description}

% We should describe our protocol in some depth here
ByteTorrent will be a BitTorrent-esque file-sharing protocol. 
Our service will contain two node-types: Clients and Trackers.
Each file will be broken into chunks, and the Tracker will maintain a list of
which clients have which chunks.

Clients will connect to each other, and will attempt to trade chunks that they
have for chunks that they want.
As with BitTorrent, Clients will not connect to all other Clients.
Rather, each Client will connect to a small number of neighbors,
suggested by the Tracker.
If a Client is unable to get a chunk from its neighbors,
it will ask the Tracker for another Client that it can connect to.

\section*{Structure}

\subsection*{Client}
The Client nodes will be implemented in Python.
They will have the following abilities:
\begin{itemize}
\item  Create new .torrent files and send them to a Tracker
%\item  Given a .torrent file, contact other clients identified in the 
%       .torrent file and request parts of a file
\item  Given a .torrent file, connect to a Tracker identified in the
       .torrent file and receive instructions.
\item  Serve parts of a file to other Clients on request
\item  Inform Tracker when it has a piece
\item  Report themselves when they do NOT have a piece that other clients
       think they do
\item  Contact Tracker when none of their neighbors have a desired piec.
\item  Connect to a new Tracker when the current connection dies.
\end{itemize}

\subsection*{Tracker Server}
The Tracker nodes will need to be highly distributed.
As such, we've decided to implement Trackers in Go.
The Trackers will be able to:
\begin{itemize}
\item  Receive new .torrent files from Clients
\item  Serve .torrent files to frontend
\item  Keep .torrent files updated
    \begin{itemize}
    \item  Add/remove Clients from list of Clients with torrent pieces
    \item  Get new .torrent files from frontend
    \end{itemize}
\end{itemize}

\subsection*{Tracker Frontend}
We ultimately aim to add a Frontend for the Trackers.
This will be done in Javascript and HTML.
Its purpose will be to:
\begin{itemize}
\item  Search for torrents by name
\item  Fetch .torrent file from backend for user to download
\item  Send new .torrent file to backend from user
\end{itemize}

\section*{Distributed Systems Concepts}

\subsection*{Clients}
The Client nodes will be in constant contact with each other.
They will need to be robust to neighbors dying, and Trackers dying.
We plan to use exponential back-off to disengage from unresponsive connections.

\subsection*{Trackers}
All Tracker servers will maintain the same data.
We will implement this with Paxos.

\section*{Test Plan}

\subsection*{Tracker Tests}
\begin{itemize}
\item  Kill a Tracker in the quorum,
       and make sure that things can still get done.
\item  Kill a Client, forcing the Trackers to update the database.
\end{itemize}

\subsection*{Client Tests}
\begin{itemize}
\item  Disengage from an unresponsive neighbor in the Client web.
\item  Connect to a new Tracker if current one becomes unresponsive.
\item  Ask a Client for a chunk that it does not have.
\end{itemize}

\section*{Development Tiers}

\subsection*{Minimum Testable Product}
\begin{itemize}
\item  Client:
    \begin{itemize}
    \item  Create .torrent files and send them directly to one tracker
    \item  Get pieces from other clients, given a .torrent
    \item  Serve pieces to other clients
    \item  Can fail without disrupting things
    \end{itemize}
\item  Tracker Server:
    \begin{itemize}
    \item  Single tracker (no Paxos)
    \item  Record when there are new files
    \item  Record when new clients get pieces of files
    \end{itemize}
\end{itemize}

\subsection*{Target Deliverable}
\begin{itemize}
\item  Client:
    \begin{itemize}
    \item  Self-report to tracker when client does not have a piece that other clients expect it to
    \item  Compute/create checksums on torrents to ensure security
    \end{itemize}
\item  Tracker Server:
    \begin{itemize}
    \item  Replicated via Paxos
    \end{itemize}
\end{itemize}

\subsection*{Stretch Goal}
\begin{itemize}
\item  Client:
    \begin{itemize}
    \item  UI: Show currently downloading/seeding files
    \end{itemize}
\item  Tracker Server:
    \begin{itemize}
    \item  Maintain users/manage logins
    \end{itemize}
\item  Tracker Frontend
\end{itemize}

\section*{Development Schedule}

\subsection*{Week 1: April 14-20}
For Week 1, our goal will be to have the Minimum Testable Product prepared.
\begin{itemize}
\item  Client:
\item  Tracker:
\end{itemize}

\subsection*{Week 2: April 21-28}
For Week 2, we will focus on getting our project to the Target Deliverable state.

\subsection*{Week 3: April 29-May 1}
In Week 3, we will work on the Stretch Goals.
In particular, this means working on the GUI.

\end{document}
